#!/usr/bin/env python3

import re
import sys
import subprocess
from typing import Iterable, Iterator
from enum import Enum, auto

DIRECTIVE_PAT = re.compile("{([^}]+)}")
TEXT_OPEN_PAT = re.compile("{(\**)")

line_rem = ""


class State(Enum):
    DEFAULT = auto()
    INCLUDE_WITH = auto()
    TEXT = auto()
    QUOTES = auto()


def strip_list(lines: Iterable[str]):
    return "".join(lines).strip()


def get_lr():
    global line_rem
    temp = line_rem
    line_rem = ""
    return temp


def set_lr(s: str):
    global line_rem
    line_rem = s


level = -1


def p(s):
    #   print(" " * level * 4 + s)
    pass


def parse(src: Iterator[str], subs: dict[str, str] = {}, exit_pat: str = ""):
    global level
    level += 1
    state = State.DEFAULT
    include_subs: dict[str, list[str] | str] = {}
    quote_buf: list[str] = []
    exit_found = False

    while True:
        try:
            if line_rem:
                line = get_lr()
            else:
                line = next(src)

            # Breaking this while implies that we've consumed the whole line
            while line:
                match state:
                    case State.INCLUDE_WITH:
                        end_idx = line.find("{endwith}")
                        end_found = end_idx != -1

                        colon_idx = line.find(":")
                        colon_found = colon_idx != -1

                        if not end_found and not colon_found:
                            break

                        if colon_found and (not end_found or colon_idx < end_idx):
                            key = line[:colon_idx].strip()
                            match = TEXT_OPEN_PAT.search(line, colon_idx + 1)
                            p("key: " + key)

                            # No braces, so we'll just take the rest of the line
                            if not end_found and not match:
                                p("branch: rest of line")
                                include_subs[key] = strip_list(
                                    parse(iter([line[colon_idx + 1:].strip()]), subs))
                                p("value: " + include_subs[key])
                                break

                            # Braces mean recursion
                            if match and (not end_found or match.start() < end_idx):
                                p("branch: recurse")
                                line = line[match.end():]
                                end_found = False

                                set_lr(line)
                                include_subs[key] = strip_list(
                                    parse(src, subs, match.group(1) + "}"))
                                line = get_lr()

                                p("value: " + include_subs[key])
                                continue

                            # We'll take the rest of the line until endwith
                            p("branch: rest of line until endwith")
                            include_subs[key] = strip_list(
                                parse(iter([line[colon_idx + 1:end_idx].strip()]), subs))
                            p("value: " + include_subs[key])

                        # Reached end of include with block
                        with open(f"templates/{filename}") as include_file:
                            yield from parse(include_file, include_subs)

                        line = line[end_idx + len("{endwith}"):]
                        include_subs.clear()
                        state = State.DEFAULT
                        p("rem: " + line)

                    case State.QUOTES:
                        match = DIRECTIVE_PAT.search(line)
                        if match and match.group(1) == "endquotes":
                            after_end = line[match.end():]
                            line = line[:match.start()]
                            state = State.DEFAULT

                        quote_buf.append(line.strip() + "\n")

                        if state is not State.QUOTES:
                            process = subprocess.run("scripts/SmartyPants.pl",
                                                     input=strip_list(
                                                         parse(quote_buf, subs)),
                                                     capture_output=True,
                                                     text=True)
                            yield process.stdout
                            quote_buf = ""
                            line = after_end
                        else:
                            break

                    case State.DEFAULT:
                        p("line: " + line)
                        if exit_pat:
                            exit_idx = line.find(exit_pat)
                            exit_found = exit_idx != -1

                        match = DIRECTIVE_PAT.search(line)

                        if not exit_found and not match:
                            yield line
                            break

                        if exit_found and not (match and match.start() < exit_idx):
                            yield line[:exit_idx]
                            set_lr(line[exit_idx + len(exit_pat):])
                            p("rem: " + line_rem)
                            level -= 1
                            return

                        yield line[:match.start()]

                        line = line[match.end():]
                        exit_found = False

                        match match.group(1).split():
                            case ["include", filename]:
                                with open(f"templates/{filename}") as file:
                                    yield from parse(file)

                            case ["include", filename, "with"]:
                                state = State.INCLUDE_WITH

                            case ["quotes"]:
                                set_lr(line)
                                yield from parse(src, subs, "{endquotes}")
                                line = get_lr()

                            case [key] if key in subs:
                                yield subs[key]

                            case _:
                                yield match.group(0)

        except StopIteration:
            break
    level -= 1


with open(sys.argv[1]) as file:
    for line in parse(file):
        print(line, end="")
