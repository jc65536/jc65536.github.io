{include page.html with}
  doc_title: PLAID
  title: Resource Management in Python Generators
  content: {
    <p>Published: August 30, 2022</p>

    {q}
      <p>
        Wow, I've never thought I'd have to deal with resource management in
        <em>Python</em> of all languages. But I did, while writing the HTML
        preprocessor for this website a couple days ago.
      </p>
        
      <p>
        A bit of context about how my preprocessor works: As it's parsing a
        file, it generates processed text, e.g. by inserting a template at a
        particular point, or by substituting symbols. Sometimes, the source
        test reading is meant to be directly written as output, but sometimes
        the source text is supposed to be saved in memory for later. I have two
        functions, <code>parse_file</code> and <code>parse_with</code>, to
        handle the two contexts, and the source file is passed between them.
        For example, as <code>parse_file</code> is reading the source file, it
        reaches a <code>\{with}</code> directive, so it then calls
        <code>parse_with</code> and passes the source file.
        <code>parse_with</code> consumes the following lines until an
        <code>{endwith}</code> signals the end of that directive, and returns
        to <code>parse_file</code>, which then continues consuming lines where
        <code>parse_with</code> left off.
      </p>
        
      <p>
        This wasn't perfect though, since files iterate over whole lines. If I
        just iterated over the file with a for loop in <code>parse_with</code>,
        I could only start reading on the line <em>after</em> the line with the
        directive, since the directive line was already consumed by
        <code>parse_file</code>. Thus, I needed to pass the remainder of the
        directive line as a parameter to <code>parse_with</code> and have it
        process the remainder before iterating through the file. Unfortunately,
        this addition turned a simple for loop into an unwieldy combination of
        a while loop and a try-except clause:
      </p>

<pre><code>def parse_with(file, remainder):
    line = remainder
    while True:
        [process line]
        try:
            line = next(file)
        except StopIteration:
            return
</code></pre>

      <p>
        This was the first time I've ever longed for a do-while loop. Even
        then, it probably would've still been clunky, as iterators always throw
        an exception upon exhaustion. This was where generators came in. All I
        needed was an iterator that "prepends" the remainder before the items
        generated by the file iterator. Here's the first generator function I
        wrote:
      </p>

<pre><code>def prepend_iter(remainder, file):
    if remainder:
        yield remainder
    yield from file
</code></pre>

      {with}
        stackoverflow: https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-yield-from-syntax-in-python-3-3
      {endwith}

      <p>
        Simple, isn't it? Just yield the remainder if any, then delegate the
        rest of the work to the file with a fancy <em>transparent bidirectional
        connection!</em> (as <a href="{stackoverflow}">one Stack Overflow
        answer</a> puts it)
      </p>
    {endq}
  }
{endwith}
